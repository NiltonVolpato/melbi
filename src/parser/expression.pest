// PEG grammar for the rhizome expression language (http://pest.rs/)

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }

main = { SOI ~ expression ~ EOI }

// We use a flat grammar since it's easier to maintain and understand, and we control
// the precedence of operators using the Pratt parser.
// 
// https://docs.rs/pest/latest/pest/pratt_parser/struct.PrattParser.html
// 
// expr = { prefix* ~ primary ~ postfix* ~ (infix ~ prefix* ~ primary ~ postfix* )* }
expression = {
    prefix_op* ~ primary ~ postfix_op* ~ (infix_op ~ prefix_op* ~ primary ~ postfix_op*)*
}

// === primary expressions ===

primary = _{
    if_expr
  | lambda
  | literal
  | ident
  | grouped
}

literal = _{ scalar_literal | composite_literal }

if_expr = { "if" ~ expression ~ "then" ~ expression ~ "else" ~ expression }

lambda        = { "(" ~ lambda_params? ~ ")" ~ "=>" ~ expression }
lambda_params = { ident ~ ("," ~ ident)* ~ ","? }

grouped = { "(" ~ expression ~ ")" }

// === prefix operations ===

prefix_op = _{
    neg
  | not
}

neg = { "-" }
not = { "not" }

// === infix operations ===

infix_op = _{
    pow
  | mul
  | div
  | add
  | sub
  | and
  | or
  | otherwise_op
}

pow = { "^" }
mul = { "*" }
div = { "/" }
add = { "+" }
sub = { "-" }
and = { "and" }
or  = { "or" }

otherwise_op = { "otherwise" }

// === postfix operations ===

postfix_op = _{
    call_op
  | index_op
  | member_op
  | where_op
  | cast_op
}

call_op   =  { "(" ~ call_args? ~ ")" }
call_args = _{ expression ~ ("," ~ expression)* ~ ","? }

index_op  = { "[" ~ expression ~ "]" }
member_op = { "." ~ ident }
where_op  = { "where" ~ "{" ~ binding_list? ~ "}" }
cast_op   = { "as" ~ type_expr }

// === type names ===

type_expr = {
    record_type
  | type_path ~ type_params?
}

record_type = {
    "Record" ~ "[" ~ type_field_list? ~ "]"
}

type_field = {
    ident ~ ":" ~ type_expr
}

type_field_list = _{
    type_field ~ ("," ~ type_field)* ~ ","?
}

type_path = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* ~ ("::" ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")*)* }

type_params = _{ "[" ~ type_expr ~ ("," ~ type_expr)* ~ "]" }

// === composite literals ===

composite_literal = _{
    record
  | array
  | map
}

// Empty records are special cased to avoid ambiguity with empty map.
record       =  { ("Record" ~ "{" ~ "}") | ("{" ~ binding_list ~ "}") }
binding_list = _{ binding ~ ("," ~ binding)* ~ ","? }
binding      =  { ident ~ "=" ~ expression }

array       =  { "[" ~ array_elems? ~ "]" }
array_elems = _{ expression ~ ("," ~ expression)* ~ ","? }

map            =  { "{" ~ map_entry_list? ~ "}" }
map_entry_list = _{ map_entry ~ ("," ~ map_entry)* ~ ","? }
map_entry      =  { expression ~ ":" ~ expression }

// === scalar literals ===

scalar_literal = _{
    boolean
  | float // must come before integer

  | integer
  | string
  | bytes
  | format_string // technically a composite literal, but we treat it as a scalar
}

boolean = { "true" | "false" }

float = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }

integer = @{ "-"? ~ ASCII_DIGIT+ }

string = @{
    ("\"" ~ (string_escape | !("\\" | "\"") ~ ANY)* ~ "\"")
  | ("'" ~ (string_escape | !("\\" | "'") ~ ANY)* ~ "'")
}

bytes = @{
    ("b\"" ~ (bytes_escape | !("\\" | "\"") ~ ANY)* ~ "\"")
  | ("b'" ~ (bytes_escape | !("\\" | "'") ~ ANY)* ~ "'")
}

format_string      = ${
    ("f\"" ~ (format_text | format_expr)* ~ "\"")
  | ("f'" ~ (format_text_single | format_expr)* ~ "'")
}
format_text        = @{
    ("{{" | "}}" | string_escape | !("{" | "}" | "\"") ~ ANY)+
}
format_text_single = @{
    ("{{" | "}}" | string_escape | !("{" | "}" | "'") ~ ANY)+
}
format_expr        = !{
    "{" ~ expression ~ "}"
}

string_escape = _{ common_escape | "\\u" ~ ASCII_HEX_DIGIT{4} | "\\U" ~ ASCII_HEX_DIGIT{8} }
bytes_escape  = _{ common_escape | "\\x" ~ ASCII_HEX_DIGIT{2} }
common_escape = _{ "\\n" | "\\r" | "\\t" | "\\\\" | "\\\"" | "\\\'" }

// === identifiers ===

ident = @{ quoted_ident | unquoted_ident }

// NOTE: Could be extended in future to allow Unicode (e.g. emojis) if desired
quoted_ident = @{ "`" ~ (ASCII_ALPHANUMERIC | "-" | "_" | "." | ":" | "/")+ ~ "`" }

reserved_words = _{
    "if"
  | "then"
  | "else"
  | "true"
  | "false"
  | "not"
  | "and"
  | "or"
  | "otherwise"
  | "as"
  | "where"
}

unquoted_ident = @{ !reserved_words ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
