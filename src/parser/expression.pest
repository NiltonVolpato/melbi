WHITESPACE = _{ " " | "\t" | "\n" | "\r" }

main = { SOI ~ expression ~ EOI }

expression = _{ if_expr | where_expr | otherwise_expr }

if_expr = {
    "if" ~ expression ~ "then" ~ expression ~ "else" ~ expression
}

where_expr = {
    otherwise_expr ~ "where" ~ "{" ~ binding_list? ~ "}"
}

cast_expr = { postfix_expr ~ ("as" ~ type_expr)? }

type_expr = {
    record_type
  | type_path ~ type_params?
}

record_type = {
    "Record" ~ "[" ~ type_field_list? ~ "]"
}

type_field = {
    ident ~ ":" ~ type_expr
}

type_field_list = _{
    type_field ~ ("," ~ type_field)* ~ ","?
}

type_path = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* ~ ("::" ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")*)* }

type_params = _{ "[" ~ type_expr ~ ("," ~ type_expr)* ~ "]" }

binding_list = _{
    binding ~ ("," ~ binding)* ~ ","?
}

binding = {
    ident ~ "=" ~ expression
}

expression_list = _{
    expression ~ ("," ~ expression)* ~ ","?
}

otherwise_expr = {
    // 'otherwise' is parsed after binary_expr to give it lower precedence.
    // This means: 'a + b otherwise c' is parsed as '(a + b) otherwise c'
    // To group 'a otherwise b + c', use parentheses: '(a otherwise b) + c'
    binary_expr ~ ("otherwise" ~ binary_expr)?
}

binary_expr = {
    unary_expr ~ (operator ~ unary_expr)*
}

unary_expr = {
    unary_op* ~ cast_expr
}

lambda = {
    "(" ~ lambda_params? ~ ")" ~ "=>" ~ expression
}

lambda_params = {
    ident ~ ("," ~ ident)* ~ ","?
}

postfix_expr = {
    primary_atom ~ postfix_op*
}

postfix_op = _{ function_call | index_access | attr_access }

function_call = { "(" ~ expression_list? ~ ")" }

index_access = { "[" ~ expression ~ "]" }

attr_access = { "." ~ ident }

primary_atom = {
    lambda
  | record
  | literal
  | array
  | map
  | ident
  | grouped
}

grouped = {
    "(" ~ expression ~ ")"
}

unary_op = {
    neg
  | not
}

neg = { "-" }
not = { "not" }

record = {
    // An empty record must be explicitly written as: Record {}
    ("Record" ~ "{" ~ "}")
  | ("{" ~ binding_list ~ "}")
}

array = {
    "[" ~ expression_list? ~ "]"
}

map = {
    "{" ~ map_entry_list? ~ "}"
}

map_entry_list = _{
    map_entry ~ ("," ~ map_entry)* ~ ","?
}

map_entry = {
    expression ~ ":" ~ expression
}

operator = {
    pow
  | mul
  | div
  | add
  | sub
  | and
  | or
}

pow = { "^" }
mul = { "*" }
div = { "/" }
add = { "+" }
sub = { "-" }
and = { "and" }
or  = { "or" }

literal = _{
    boolean
  | float
  | integer
  | string
  | bytes
  | format_string
}

boolean = { "true" | "false" }

integer = @{ "-"? ~ ASCII_DIGIT+ }

float = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }

string = @{
    ("\"" ~ (string_escape | !("\\" | "\"") ~ ANY)* ~ "\"")
  | ("'" ~ (string_escape | !("\\" | "'") ~ ANY)* ~ "'")
}

bytes = @{
    ("b\"" ~ (bytes_escape | !("\\" | "\"") ~ ANY)* ~ "\"")
  | ("b'" ~ (bytes_escape | !("\\" | "'") ~ ANY)* ~ "'")
}

format_string = ${
    ("f\"" ~ (format_text | format_expr)* ~ "\"")
  | ("f'" ~ (format_text_single | format_expr)* ~ "'")
}

format_text = @{
    ("{{" | "}}" | string_escape | !("{" | "}" | "\"") ~ ANY)+
}

format_text_single = @{
    ("{{" | "}}" | string_escape | !("{" | "}" | "'") ~ ANY)+
}

format_expr = !{
    "{" ~ expression ~ "}"
}

string_escape = {
    "\\n"
  | "\\r"
  | "\\t"
  | "\\\\"
  | "\\\""
  | "\\\'"
  | "\\u" ~ ASCII_HEX_DIGIT{4}
  | "\\U" ~ ASCII_HEX_DIGIT{8}
}

bytes_escape = {
    "\\n"
  | "\\r"
  | "\\t"
  | "\\\\"
  | "\\\""
  | "\\\'"
  | "\\x" ~ ASCII_HEX_DIGIT{2}
}

ident = @{ quoted_ident | unquoted_ident }

// NOTE: Could be extended in future to allow Unicode (e.g. emojis) if desired
quoted_ident = @{ "`" ~ (ASCII_ALPHANUMERIC | "-" | "_" | "." | ":" | "/")+ ~ "`" }

unquoted_ident = @{ !("true" | "false" | "not" | "and" | "or") ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
